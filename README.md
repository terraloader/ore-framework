<div align="center">
  <img src="www/images/ore-logo.png" alt="Ore" width="400">
  <br><br>
  <strong>A backend framework that pre-calculates data and serves fully server-rendered Vue apps — with automatic client-side hydration.</strong>
  <br><br>

  ![Node.js](https://img.shields.io/badge/Node.js-18%2B-339933?style=flat-square&logo=node.js&logoColor=white)
  ![Vue 3](https://img.shields.io/badge/Vue-3-4FC08D?style=flat-square&logo=vue.js&logoColor=white)
  ![License](https://img.shields.io/badge/license-MPL--2.0-blue?style=flat-square)
  <br><br>
  <a href="https://ore-framework-ace3aaf93391.herokuapp.com/">Live Demo</a>
</div>

---

## What is Ore?

Ore is a lightweight Node.js backend framework built around one idea: **run all your logic on the server, assign the results to a Vue template, and ship a fully rendered HTML page** — no client-side data fetching, no loading spinners.

Every URL maps to a component directory. The component's JavaScript file runs server-side, pushes data through `Ore.vue.assign()`, and Ore handles the rest — compiling the Vue SFC, rendering it to HTML, injecting the state, and sending a complete page to the browser. A client-side Vue app is then bootstrapped automatically from the same component and takes over the server-rendered DOM via hydration, making the page fully interactive without a re-render.

---

## Project structure

```
ore-framework/
├── classes/
│   ├── Ore.js          Global singleton — lazy entry point for all classes
│   ├── Router.js       Maps URL paths to component directories
│   ├── Vue.js          SSR renderer, client compiler, state store
│   └── Db.js           Lazy-connected database helper
│
├── components/         One subdirectory per route
│   └── test/
│       ├── index.js    Component logic (runs server-side)
│       └── index.vue   Vue 3 SFC template
│
├── www/                Web server entry point + public assets
│   ├── index.js        HTTP server
│   ├── css/
│   │   └── main.css
│   └── images/
│
└── package.json
```

---

## Quick start

```bash
npm install
node www/index.js
```

The server starts on `http://localhost:3000` by default.
Visit `http://localhost:3000/test` to see the example component in action.

| Environment variable | Default     | Description              |
|----------------------|-------------|--------------------------|
| `PORT`               | `3000`      | HTTP listen port         |
| `DB_HOST`            | `localhost` | Database host            |
| `DB_PORT`            | `3306`      | Database port            |
| `DB_USER`            | `root`      | Database user            |
| `DB_PASSWORD`        | *(empty)*   | Database password        |
| `DB_NAME`            | `ore`       | Database name            |

---

## How a request flows

```
GET /test
  │
  ├─▶  www/index.js               static? → serve directly from www/
  │
  ├─▶  Router.js                  resolves /test → components/test/
  │
  ├─▶  components/test/index.js   runs server-side
  │       Ore.vue.assign('title', 'Test Page')
  │       Ore.vue.assign('rows',  await Ore.db.fetchAllRows('SELECT …'))
  │
  ├─▶  Vue.js                     compiles index.vue (SSR), injects assignments,
  │                               renders to HTML, embeds state + hydration script
  │
  └─▶  browser                    receives complete HTML (no blank flash)
         │
         ├─▶  GET /ore/component.js?c=test   server compiles index.vue for
         │                                   the browser and returns it as JS
         │
         └─▶  createSSRApp({ render, setup() { return __ORE_STATE__[id] } })
                app.mount('#ore-<instanceId>')   ← hydrates, no re-render
```

---

## How hydration works

Ore uses three distinct identifiers per render, each with a separate purpose:

| ID | Generated by | Purpose |
|---|---|---|
| **scope ID** | SHA-256 hash of the `.vue` file path (first 8 chars) | CSS `<style scoped>` attribute (`data-v-<id>`). Identical on server and client, unique per component file. |
| **component ID** | Relative route path (e.g. `test`, `admin/users`) | Identifies which `.vue` file to compile for the browser. Used as the `c=` query parameter on `/ore/component.js`. |
| **instance ID** | `randomBytes(6)` per `render()` call | Ties one specific server render to one specific client hydration. Keyed in `window.__ORE_STATE__` and used as the DOM mount point (`#ore-<id>`). |

The instance ID is what allows multiple renders of the same (or different) components to coexist on one page — each instance has its own mount point and its own state slice.

### The `/ore/component.js` endpoint

`GET /ore/component.js?c=<componentId>` compiles the component's `<template>` for the browser (client-side render function, not SSR) and returns it as a JavaScript module. The browser imports it as:

```js
import { render } from '/ore/component.js?c=test'
```

The `c` parameter is the component's route path. Path traversal is rejected server-side.

---

## Creating a route

Add a new directory under `components/` — no registration or config needed. The Router resolves routes by filesystem path.

**`components/hello/index.js`**
```js
export default async function (req, res) {
  Ore.vue.assign('greeting', 'Hello, world!')
  Ore.vue.assign('time', new Date().toLocaleTimeString())
}
```

**`components/hello/index.vue`**
```vue
<template>
  <main>
    <h1>{{ greeting }}</h1>
    <p>Server time: {{ time }}</p>
  </main>
</template>

<script setup>
</script>
```

That's it. `GET /hello` now renders this page with the assigned data baked in and a hydrated Vue app running in the browser.

---

## The `Ore` global

`Ore` is available everywhere — no `import` needed. Every property is **lazy**: the underlying class is instantiated only when first accessed, so unused features (like the database) cost nothing at startup.

| Property | Class | Description |
|---|---|---|
| `Ore.vue` | `classes/Vue.js` | Assign data · render SFCs · compile for client |
| `Ore.db` | `classes/Db.js` | Query the database (connects on first use) |
| `Ore.router` | `classes/Router.js` | Route requests to components |

### `Ore.vue`

```js
Ore.vue.assign('key', value)   // set a template variable (chainable)
Ore.vue.assign('a', 1).assign('b', 2)

Ore.vue.get('key')             // read a single value
Ore.vue.getAll()               // { key: value, … }
Ore.vue.reset()                // clear all assignments (done automatically per request)

await Ore.vue.render('/path/to/component.vue')
// Returns a full HTML document with the SSR body, embedded state, and
// a <script type="module"> that hydrates the page in the browser.

await Ore.vue.compileForClient('/path/to/component.vue')
// Returns the component's client-side render function as a JS module string.
// Called automatically by the /ore/component.js endpoint.
```

### `Ore.db`

```js
const rows = await Ore.db.fetchAllRows('SELECT * FROM posts WHERE active = ?', [1])
const row  = await Ore.db.fetchRow('SELECT * FROM users WHERE id = ?', [42])
const res  = await Ore.db.execute('INSERT INTO logs (msg) VALUES (?)', ['hello'])
```

The database connection is opened the first time any of these methods is called.
To configure the driver, replace `_connect()` in `classes/Db.js` with your preferred library (`mysql2`, `pg`, `better-sqlite3`, etc.).

---

## Static assets

Files under `www/css/` and `www/images/` are served directly by the HTTP server without going through the router.

```
www/css/main.css          →  /css/main.css
www/images/ore-logo.png   →  /images/ore-logo.png
```

---

## License

Mozilla Public License 2.0 — see [LICENSE](LICENSE) for details.
